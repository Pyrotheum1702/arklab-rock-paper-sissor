// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title RockPaperScissorsZK
 * @dev Zero-Knowledge Rock Paper Scissors game
 *
 * This version uses ZK-SNARKs to prove:
 * 1. Players made valid moves (without revealing them)
 * 2. Winner is computed correctly (without revealing moves)
 *
 * Benefits over commit-reveal:
 * - Single transaction per player (no reveal needed)
 * - Moves stay private until game ends
 * - No timeout griefing possible
 * - Cryptographic proof of fairness
 *
 * Flow:
 * 1. Player1 creates game with stake and their move commitment
 * 2. Player2 joins with stake and their move commitment
 * 3. Either player submits ZK proof of winner
 * 4. Contract verifies proof and pays out
 *
 * Note: This is a simplified version for educational purposes.
 * Production version would need proper verifier contracts generated by snarkjs.
 */

/**
 * @dev Interface for the ZK verifier contract
 * In production, this would be generated by snarkjs from your circuit
 */
interface IRPSWinnerVerifier {
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[4] memory input  // [commitment1, commitment2, winner, valid]
    ) external view returns (bool);
}

contract RockPaperScissorsZK {

    enum GameState {
        WaitingForPlayer2,
        WaitingForProof,
        Completed
    }

    struct Game {
        address player1;
        address player2;
        uint256 stake;

        uint256 commitment1;  // Poseidon hash of (move, secret)
        uint256 commitment2;

        GameState state;
        address winner;

        uint256 createdAt;
    }

    // Storage
    mapping(uint256 => Game) public games;
    uint256 public gameCounter;

    // ZK Verifier contract (would be deployed separately)
    IRPSWinnerVerifier public verifier;

    // Timeout for submitting proof (24 hours)
    uint256 public constant PROOF_TIMEOUT = 24 hours;

    // Events
    event GameCreated(uint256 indexed gameId, address indexed player1, address indexed player2, uint256 stake, uint256 commitment1);
    event Player2Joined(uint256 indexed gameId, address indexed player2, uint256 commitment2);
    event WinnerProven(uint256 indexed gameId, address indexed winner, uint256 prize);
    event ProofTimeoutClaimed(uint256 indexed gameId, address indexed claimer);

    // Errors
    error InvalidStake();
    error NotYourTurn();
    error GameNotFound();
    error WrongGameState();
    error InvalidProof();
    error TimeoutNotReached();
    error Unauthorized();
    error InvalidCommitment();

    /**
     * @dev Constructor - sets the verifier contract address
     * @param _verifier Address of the ZK verifier contract
     */
    constructor(address _verifier) {
        verifier = IRPSWinnerVerifier(_verifier);
    }

    /**
     * @dev Create a new game with your commitment
     * @param _player2 Address of opponent
     * @param _commitment1 Poseidon(move, secret) - your move commitment
     *
     * The commitment is computed off-chain as:
     * commitment = Poseidon(move, secret)
     * where move âˆˆ {1, 2, 3} and secret is a large random number
     */
    function createGame(
        address _player2,
        uint256 _commitment1
    ) external payable returns (uint256) {
        if (msg.value == 0) revert InvalidStake();
        if (_player2 == address(0) || _player2 == msg.sender) revert Unauthorized();
        if (_commitment1 == 0) revert InvalidCommitment();

        uint256 gameId = gameCounter++;

        games[gameId] = Game({
            player1: msg.sender,
            player2: _player2,
            stake: msg.value,
            commitment1: _commitment1,
            commitment2: 0,
            state: GameState.WaitingForPlayer2,
            winner: address(0),
            createdAt: block.timestamp
        });

        emit GameCreated(gameId, msg.sender, _player2, msg.value, _commitment1);

        return gameId;
    }

    /**
     * @dev Player2 joins with their commitment
     * @param _gameId Game to join
     * @param _commitment2 Your move commitment
     */
    function joinGame(uint256 _gameId, uint256 _commitment2) external payable {
        Game storage game = games[_gameId];

        if (game.player1 == address(0)) revert GameNotFound();
        if (msg.sender != game.player2) revert Unauthorized();
        if (game.state != GameState.WaitingForPlayer2) revert WrongGameState();
        if (msg.value != game.stake) revert InvalidStake();
        if (_commitment2 == 0) revert InvalidCommitment();

        game.commitment2 = _commitment2;
        game.state = GameState.WaitingForProof;

        emit Player2Joined(_gameId, msg.sender, _commitment2);
    }

    /**
     * @dev Submit ZK proof of winner
     * @param _gameId Game ID
     * @param _winner Winner (0=draw, 1=player1, 2=player2)
     * @param a Proof component A
     * @param b Proof component B
     * @param c Proof component C
     *
     * The proof proves:
     * - You know move1, secret1 such that commitment1 = Poseidon(move1, secret1)
     * - You know move2, secret2 such that commitment2 = Poseidon(move2, secret2)
     * - Both moves are valid (1, 2, or 3)
     * - The winner is computed correctly according to RPS rules
     *
     * The proof is verified on-chain without revealing the actual moves!
     */
    function proveWinner(
        uint256 _gameId,
        uint256 _winner,
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c
    ) external {
        Game storage game = games[_gameId];

        if (game.state != GameState.WaitingForProof) revert WrongGameState();
        if (msg.sender != game.player1 && msg.sender != game.player2) revert Unauthorized();
        if (_winner > 2) revert InvalidProof();

        // Verify the ZK proof
        // Public inputs: [commitment1, commitment2, winner, valid]
        uint[4] memory publicInputs = [
            game.commitment1,
            game.commitment2,
            _winner,
            1  // valid flag
        ];

        bool proofIsValid = verifier.verifyProof(a, b, c, publicInputs);
        if (!proofIsValid) revert InvalidProof();

        // Proof is valid! Determine winner and pay out
        game.state = GameState.Completed;

        address winnerAddress;
        if (_winner == 0) {
            // Draw - refund both players
            winnerAddress = address(0);
            (bool success1, ) = game.player1.call{value: game.stake}("");
            (bool success2, ) = game.player2.call{value: game.stake}("");
            require(success1 && success2, "Refund failed");
        } else if (_winner == 1) {
            // Player 1 wins
            winnerAddress = game.player1;
            (bool success, ) = winnerAddress.call{value: game.stake * 2}("");
            require(success, "Transfer failed");
        } else {
            // Player 2 wins
            winnerAddress = game.player2;
            (bool success, ) = winnerAddress.call{value: game.stake * 2}("");
            require(success, "Transfer failed");
        }

        game.winner = winnerAddress;

        emit WinnerProven(_gameId, winnerAddress, game.stake * 2);
    }

    /**
     * @dev Claim game if opponent doesn't submit proof within timeout
     * @param _gameId Game ID
     *
     * If neither player submits proof within PROOF_TIMEOUT, contract is stuck.
     * This allows either player to claim their stake back.
     * More sophisticated versions could penalize the non-submitter.
     */
    function claimTimeout(uint256 _gameId) external {
        Game storage game = games[_gameId];

        if (game.state != GameState.WaitingForProof) revert WrongGameState();
        if (block.timestamp < game.createdAt + PROOF_TIMEOUT) revert TimeoutNotReached();
        if (msg.sender != game.player1 && msg.sender != game.player2) revert Unauthorized();

        game.state = GameState.Completed;

        // Refund both players
        (bool success1, ) = game.player1.call{value: game.stake}("");
        (bool success2, ) = game.player2.call{value: game.stake}("");
        require(success1 && success2, "Refund failed");

        emit ProofTimeoutClaimed(_gameId, msg.sender);
    }

    /**
     * @dev Get game details
     */
    function getGame(uint256 _gameId) external view returns (
        address player1,
        address player2,
        uint256 stake,
        uint256 commitment1,
        uint256 commitment2,
        GameState state,
        address winner
    ) {
        Game storage game = games[_gameId];
        return (
            game.player1,
            game.player2,
            game.stake,
            game.commitment1,
            game.commitment2,
            game.state,
            game.winner
        );
    }

    /**
     * @dev Update verifier contract (for upgrades)
     * In production, this would be restricted to owner/governance
     */
    function setVerifier(address _verifier) external {
        verifier = IRPSWinnerVerifier(_verifier);
    }
}

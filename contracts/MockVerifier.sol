// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title MockVerifier
 * @dev Mock ZK verifier for testing purposes
 *
 * In production, you would use the verifier generated by snarkjs.
 * This mock allows us to test the game logic without needing
 * the full ZK setup (which requires Circom compiler, trusted setup, etc.)
 *
 * For testing, this verifier will accept any proof where:
 * - commitment1 and commitment2 are non-zero
 * - winner is 0, 1, or 2
 *
 * To generate real proofs, you need to:
 * 1. Compile circuits with circom
 * 2. Run powers of tau ceremony
 * 3. Generate proving and verification keys
 * 4. Use snarkjs to generate the verifier contract
 */
contract MockVerifier {
    /**
     * @dev Mock verification - always returns true for testing
     * @param a Proof component A
     * @param b Proof component B
     * @param c Proof component C
     * @param input Public inputs [commitment1, commitment2, winner, valid]
     */
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[4] memory input
    ) external pure returns (bool) {
        // Silence unused variable warnings
        a; b; c;

        // Basic sanity checks
        require(input[0] != 0, "commitment1 must be non-zero");
        require(input[1] != 0, "commitment2 must be non-zero");
        require(input[2] <= 2, "winner must be 0, 1, or 2");
        require(input[3] == 1, "valid flag must be 1");

        // In production, this would verify the actual ZK proof
        // For testing, we just return true
        return true;
    }
}

/**
 * @title TestVerifier
 * @dev Verifier that computes winner on-chain for testing
 *
 * This is NOT zero-knowledge! It's only for demonstration.
 * It shows what the ZK circuit proves, but without privacy.
 */
contract TestVerifier {
    /**
     * @dev Compute winner from moves (for testing only)
     * @param move1 Player 1's move
     * @param move2 Player 2's move
     * @return winner 0=draw, 1=player1, 2=player2
     */
    function computeWinner(uint256 move1, uint256 move2) public pure returns (uint256) {
        require(move1 >= 1 && move1 <= 3, "Invalid move1");
        require(move2 >= 1 && move2 <= 3, "Invalid move2");

        if (move1 == move2) return 0; // Draw

        // Rock (1) beats Scissors (3)
        // Paper (2) beats Rock (1)
        // Scissors (3) beats Paper (2)

        if (
            (move1 == 1 && move2 == 3) ||
            (move1 == 2 && move2 == 1) ||
            (move1 == 3 && move2 == 2)
        ) {
            return 1; // Player 1 wins
        }

        return 2; // Player 2 wins
    }

    /**
     * @dev Mock verification using move computation
     * This is for TESTING ONLY - it's not zero-knowledge!
     */
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[4] memory input
    ) external pure returns (bool) {
        // Silence warnings
        a; b; c;

        // input[0] = commitment1 (we'll treat as move1 for testing)
        // input[1] = commitment2 (we'll treat as move2 for testing)
        // input[2] = claimed winner
        // input[3] = valid flag

        uint256 move1 = input[0];
        uint256 move2 = input[1];
        uint256 claimedWinner = input[2];

        require(input[3] == 1, "valid flag must be 1");

        // Compute actual winner
        uint256 actualWinner = computeWinner(move1, move2);

        // Proof is valid if claimed winner matches actual winner
        return actualWinner == claimedWinner;
    }
}
